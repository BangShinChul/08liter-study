# 데이터베이스(MYSQL)

서버에서 가장 중요한 것 중 하나는 데이터베이스 임. 클라이언트가 요청한 데이터는 데이터베이스에서 가져온 값을 가져다 줄 것이고, 클라이언트가 회원가입을 시도하면 유저 정보를 데이터베이스에 저장함. 그래서 데이터베이스를 조작하는 것은 서버를 만드는데 있어 매우 중요한 부분임.

## database 이해

데이터베이스를 조작하기 위해 가장 먼저 데이터를 저장할 데이블을 만들어야 함. 테이블을 만들기 전에 데이터베이스를 먼저 생성하고 선택된 데이터베이스에 데이터를 저장할 테이블을 생성함.

### 데이터베이스 생성

```
CREATE DATABASE [데이터베이스 이름];
```

데이터베이스를 조작하는 명령어는 *쿼리문(질의문), SQL*

### 데이터베이스 조회

```
SHOW DATABASE;
```

데이터베이스를 확인하면 데이터베이스 리스트를 출력함

### 데이터베이스 선택

```
USE [데이터베이스 이름];
```

테이블 생성, 데이터 조작 등의 쿼리문들은 USE로 선택한 데이터베이스에서 조작됨

### 데이터베이스 삭제

```
DROP DATABASE [데이터베이스 이름];
```

### 테이블 조회

```
SHOW TABLES;
```

테이블 조작을 시도할 때 주의할 점은 USE를 이용하여 데이터베이스를 선택해야함

### 테이블 생성

```
CREATE TABLE info(
name VARCHAR(255) NOT NULL,
age INT(4)
);
```

info라는 테이블을 생성하고 name과 age 칼럼을 생성함

*VARCHAR,INT,NOT NULL*들은 컬럼의 타입과 옵션을 부여하는 부분임.

칼럼은 다음과 같이 정의하여 테이블을 생성할 수 있음.

```
컬럼 이름 컬럼 타입 (길이) 옵션 정보
```

#### 컬럼 타입

MySQL에서 주로사용하는 컬럼 타입은 다음과 같음

- *CHAR* : CHAR은 문자열을 저장하는 타입임. CHAR(10)으로 하면 10바이트(길이)를 사용하여 문자열을 저장함. CHAR은 길이가 고정되어 있으므로 10바이트가 안 되는 문자열을 저장하더라도 10바이트로 채워서 저장함
- *VARCHAR* : VARCHAR은 CHAR과 마찬가지로 문자열을 저장하는 타입임. VARCHAR은 가변적으로 텍스트를 채웁니다. VARCHAR(10)으로 10개의 길이까지 저장한다고 했을때 만약 5길이를 가진 문자열을 저장한다면 10바이트를 다 채우지 않고 저장함.
- *TEXT* : TEXT 타입은 CHAR, VARCHAR처럼 문자열을 저장함. 하지만 TEXT는 길이를 따로 설정하지 않음. 최대 65535(2^15-1)바이트까지 저장함
- *INT* : INT는 정수 타입의 데이터를 저장함
- *FLOAT* : FLOAT는 실수 타입의 데이터를 저장함
- *DATETIME* : DATETIME 타입은 날짜 + 시간 형태로 데이터를 저장함. 기본적으로 YYYY-MM-DD HH:MM:SS 형태로 저장함
- *DATE* : DATE 타입은 날짜를 저장함. 기본적으로 YYYY-MM-DD 형태로 저장함.

#### 컬럼 옵션

- *NOT NULL* : 해당 컬럼의 값이 반드시 있어야 하는 것을 의미함
- *PRIMARY KEY* : PRIMARY KEY로 설정된 컬럼은 해당 테이블의 키임. PRIMARY KEY는 하나의 테이블에서 2개를 가질 수 없음.
- *DEFAULT* : 해당 컬럼에 데이터가 없다면 기본값을 설정할 때 사용함. DEFAULT 5으로 설정하고 해당 컬럼에 값이 없다면 10을 기본값으로 사용하는 것을 의미함.
- *AUTO_INCREMENT* : AUTO_INCREMENT는 해당 컬럼이 INT 타입일 때만 사용 가능함. 주로 유니크한 값을 만들 때 사용되며 해당 컬럼에 데이터를 넣지 않아도 데이터베이스가 행이 늘어날 때마다 +1 값을 넣어줌.

### 데이블 정보 확인

```
DESC [테이블 명];
```

컬럼(필드) 이름, 데이터 타입, 널값 허용 유무, 키 여부, 기본값 설정, 키타 설정값을 볼 수 있음.

### 테이블 정보 수정

새로운 컬럼 추가, 기존 컬럼 타입 변경, 컬럼 이름 변경, 컬럼 삭제하기를 할 수 있음

#### 새로운 컬럼 추가

```
ALTER TABLE [테이블 이름] ADD COLUMN [컬럼 이름] [컬럼 타입] [컬럼 옵션];
```

예제)

```
ALTER TABLE info ADD COLUMN address VARCHAR (255);
```

info 테이블에 VARCHAR(255) 타입의 address 컬럼을 추가

#### 컬럼 타입 변경

```
ALTER TABLE [테이블 이름] MODIFY COLUMN [컬럼 이름] [변경할 컬럼 타입]
```

#### 컬럼 삭제

```
ALTER TABLE [테이블 이름] DROP COLUMN [컬럼 이름]
```

#### 테이블 삭제

```
DROP TABLE [테이블 이름]
```

### INSERT 문을 이용한 데이터 삽입

```
INSERT INTO [테이블 이름] (컬럼, 컬럼) VALUES(",");
```

예)
```
INSERT INTO users (age, name) VALUES(27, seongjoo);
```

### SELECT 문을 이용한 데이터 조

SELECT 문을 이용하면 INSERT로 데이터를 넣은 것들을 조회할 수 있음.

#### SELECT 구조

```
SELECT [컬럼] FROM [테이블 이름]
```

컬럼 자리에 *을 넣으면 모든 컬럼을 조회한다는 의미함

#### 데이터 정렬

SELECT 문은 데이터를 자동으로 정렬하지 않고, 데이터를 넣은 순서대로 저장함.

데이터를 정렬할  *ORDER BY*를 사용함

```
ORDER BY [컬럼 이름] DESC

ORDER BY [컬럼 이름] ASC
```

DESC은 내림차순, ASC는 오름차순임

#### 데이터 제한

SELECT 문으로 조회되는 결과의 데이터 개수를 제한하거나 특정 위치부터 조회할 수 있음.<br>
*OFFSET*과 *LIMIT*을 사용함.

LIMIT는 데이터를 몇 개 출력할지 결정하는 옵션임.

LIMIT 1은 하나의 데이터만 출력하겠다는 것을 의미함.

LIMIT은 숫자 2개를 사용할 수 있음. LIMIT 0, 10과 같은 형태로 사용가능함. 이 부분이 의미하는 것 0번째부터 10개까지만 데이터를 가져온다는 의미임

OFFSET은 몇번째 떨어져 있는 데이터인지 나타내는 옵션임.

OFFSET 2 LIMIT 2;라고 하면 2번째 떨어진 데이터에서 2개의 데이터를 조회하라는 의미임.

LIMIT와 OFFSET은 항상 마지막에 나와야함

#### WHERE 문을 이용한 필터

WHERE 문을 이용하면 필터링된 결과를 볼 수 있음

```
SELECT *FROM users WHERE id = 1;
```
id가 1인 값을 조회함. 2개 이상의 조건을 검색하거나 여러 관계를 필터링할 땐 AND와 OR을 사용함

*AND* : AND로 연산하는 관계는 양쪽 모두 참일 때 참값이 됨

*OR* : OR 연산은 하나라도 참인 데이터를 찾음

*LIKE* : 문자열을 검색할때 특정 문자열의 일치 여부는 =을 사용하면 됨.

문자열 포함 여부에 따라 조회하고 싶을때 *like '문자'* 형태로 사용됨.

*%문자* 의 경우 문자로 끝나는 모든 문자열을 검색함

*문자%* 의 경우는 문자로 시작하는 모든 문자열을 검색함.

*%문자%* 는 문자가 포함된 모든 문자열을 검색함.

like 문을 너무 남용하면 성능 저하가 일어날 수 있으므로 되도록 =을 이용하여 검사를 하는게 좋음.

### UPDATE 문을 이용한 데이터 수정

```
UPDATE [테이블 명] SET [수정값] WHERE [조건];
```

UPDATE 문에서 가장 중요한 점은 WHERE 가 꼭 있어야 한다는 점.

다수의 컬럼은 수정하고 싶을 땐 *SET 컬럼 = 값, 컬럼 = 값* 형태로 나열하면 됨

### DELETE 문을 이용한 데이터 삭제

```
DELETE FROM [테이블 명] WHERE [조건];
```

DELETE은 WHERE가 없으면 모든 데이터를 삭제함.

### JOIN

다수의 테이블을 하나의 검색 결과로 조회할 수 있음

join을 이용할 때 다수의 테이블을 명시하게 됨. 그러므로 컬럼명만 적으면 어느 테이블의 컬럼인지 알 수 없으므로 *테이블.컬럼*의 형태로 작성함.

데이터베이스를 설계하면서 가장 중효한 건 중복된 데이터를 만들지 않는 것임.

이러한 형태로 데이터베이스를 설계하는 방식을 정규화라고 함.

서비스가 커질수록 구조를 잘 설계하고 중복되는 데이터를 만들지 않아야 유지보수 비용을 최소화 할 수 있음.

그렇지만 정규화를 하면 할수록 테이블이 쪼개지기 때문에 쿼리문을 작성하는데 어려움이 있음. 또한, 다른 테이블을 조회하기 때문에 성능상 이슈가 발생할 수 있음.

### database 연결

node.js MySQL에 연결하기 위해 mysql이라는 패키지를 사용함.

```
npm init

npm install -s mysql
```

```
const mysql = require('mysql')

let db = mysql.createConnection({
    host:'127.0.0.1',
    port:'3306',
    user:'root'
    password:'',
    database:'boards'
});
```

mysql 패키지를 require을 이용하여 가져옴. createConnection을 호출하여 디비 연결 객체를 만들어 줌.

- host : 서버 주소, 여기서 서버란 디비서버를 의미함 (127.0.0.1은 로컬로 접속한다는 의미)
- port : 해당 서버의 포트 번호(MySQL의 기본 포트 번호는 3306번 임)
- user : 유저 이름
- password : 비밀번호
- database : 데이터베이스 이름(데이터베이스에서 CREATE DATABASE로 생성한 이름)

### 디비 조작

연결된 DB 객체를 이용하여 데이터베이스를 조작할 수 있음

디비를 조작하는 방법은 query 함수를 호출하여 앞에서 배운 쿼리문을 넣어주면 끝임. 

콜백으로는 결과 값을 전달 받음. 콜백으로 전달받을 땐 첫 번째 인자는 에러값, 두 번째 인자로 데이터를 받음.

```
db.query('SELECT *FROM users', (err, data) => {
    if(err) console.log('err 발생 : ' + err)
    else console.log(data);
});
```

### replace

WHERE를 이용하면 서버에 요청한 id를 통해 해당 데이터만 조회할 수 있음.

동적으로 바뀌는 위치를 물음표(?)로 넣어줌. query에서 두 번째 인자로 물음표에 들어갈 값을 리스트 형태로 넣어주면 됨. 쿼리가 동작할 땐 물음표가 두 번째 인자로 전달한 리스트에서 순서대로 대체됨.


```
let sql = `SELECT *FROM users WHERE id=? AND name=? AND age=?`
db.query(sql, [1, 'jinseongjoo', 25], (err, data) => {
    res.join(data)
})
```

위와 같은 형태로 작성되면 SELECT *FROM users WHERE id=1 AND name=jinseongjoo AND age=25로 바뀐 쿼리문을 사용함.

직접 쿼리문을 만드는 것 보다 ?를 사용하여 대체하는 방법을 사용하는 것이 좋음.

### promise / async / await

코드 유지를 위해서는 콜백 형태를 그냥 사용하는 것보다 Promise 패턴이나 async/await를 사용하는 것이 유지보수 하는데 수월함.

*콜백 형태, Promise 패턴, async/await* 중 편한 방법을 사용하면 됨.